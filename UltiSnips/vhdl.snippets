# sl - signal std_logic
# sv - signal std_logic_vector
# ss - signal signed
# su - signal unsigned
# si - signal integer
# sb - signal boolean

# vl - variable std_logic
# vv - variable std_logic_vector
# vs - variable signed
# vu - variable unsigned
# vi - variable integer

# il - in std_logic
# iv - in std_logic_vector
# ol - out std_logic
# ov - out std_logic_vector

# bl - block

# gif - generate if
# gfor - generate for

# for - for loop

# ta - type array
# tr - type record

# pr - will expand out sync / async if clk is in the signal name
# pra - all  - vim-snippets
# prc - clk  - vim-snippets

# lib - a lib to complete
# libs - std enitity libs 
# unisim  - unisim lib

global !p
import px.snippets
endglobal

global !p

# This function will jump to next placeholder when first is empty.
def jump_to_second_when_first_is_empty(snip):
    if px.snippets.get_jumper_position(snip) == 1:
        if not px.snippets.get_jumper_text(snip):
            px.snippets.advance_jumper(snip)

# This function will clean up first placeholder when this is empty.
def clean_first_placeholder(snip):
    # Jumper is a helper for performing jumps in UltiSnips.
    px.snippets.make_jumper(snip)

    if snip.tabstop == 2 and not px.snippets.get_jumper_text(snip):
        line = snip.buffer[snip.cursor[0]]
        snip.buffer[snip.cursor[0]] = \
            line[:snip.tabstops[1].start[1]-2] + \
            line[snip.tabstops[1].end[1]+1:]
        snip.cursor.set(
            snip.cursor[0],
            snip.cursor[1] - 3,
        )

def test_jump_1_2_2(snip, tabstop):
    return px.snippets


def goto_eol(snip):
    cur_line_length = len(snip.buffer[snip.line])
    snip.cursor.set(
        snip.cursor[0],
        cur_line_length+1,
    )

def insert_method_call(name):
	vim.command('normal G')
	snip.expand_anon(name + '($4)\n')
 
#def skip(snip):
#    if px.snippets.get_jumper_position(snip) == 2:
#        if not px.snippets.get_jumper_text(snip):
#            px.snippets.advance_jumper(snip)

# def make_jumper(snip, on_tabstop=1):
#     if snip.tabstop != on_tabstop:
#         return
# 
#     snip.context.update({'jumper': {'enabled': True, 'snip': snip}})

# theres a dummy context 
# so you can create a jumper and access the snip object

def jump(snip, tabstop):
    px.snippets.make_jumper(snip, 2)
    if snip.tabstop == tabstop and not px.snippets.get_jumper_text(snip):
        px.snippets.advance_jumper(snip)

def auto_postjump(snip):
    px.snippets.make_jumper(snip, 2)

def autojump(snip):
    if not px.snippets.get_jumper_text(snip):
        px.snippets.advance_jumper(snip)



endglobal
 
#############################################
#  This is a dev secton for playing around  #
#############################################
 
context "px.snippets.make_context(snip)"
post_jump "clean_first_placeholder(snip)"
snippet x "Description" b
`!p jump_to_second_when_first_is_empty(snip)
`func (${1:blah}) $2() {
    $3
}
endsnippet

#trying to make autojump if string is empty
context "px.snippets.make_context(snip)"
post_jump "px.snippets.make_jumper(snip, 2)"
snippet ll
this is a test
`!p autojump(snip)`
ts 1 = ${1:test1}
ts 2 = ${2:test2}
ts 3 = ${3:test3}
ts 4 = ${4:test4}
endsnippet

post_jump "if snip.tabstop == 0: insert_method_call(snip.tabstops[1].current_text)"
snippet dbg_d "method declaration" b
def $1():
	2 = ${2}
	3 = ${3}
endsnippet
                                 

snippet dbg_f
entity ${1:`!p snip.rv=snip.basename`} is
	generic
	(
		${3}
	); `!p
if t[1] == "tb":
	snip += "end entity %s;" % t[1];
else:
	snip >> 1
	snip += "port"
	snip += "("
	snip += ")"
	snip << 1
	snip += "end entity %s;" % t[1];
`

architecture `!p snip.rv = "sim" if t[1] in "tb" else "rtl" ` of $1 is
	${4}
begin
	${5}
end architecture $1;
endsnippet

snippet dbg_e
entity ${1:`!p snip.rv=snip.basename`} is
	generic
	(
		${3}
	);`!p 
if t[1] == "tb":
	snip += "end entity %s;" % t[1];
else:
	snip >> 1
	snip += "port"
	snip += "("
	snip += ")"
	snip << 1
	snip += "end entity %s;" % t[1];
`

architecture `!p snip.rv = "sim" if t[1] in "tb" else "rtl" ` of $1 is
	${0}
begin
end architecture $1;
endsnippet

snippet dbg_slv "Description" 
std_logic_vector(${1} downto 0)${2: := (others => '0')};${3}
endsnippet       
 
# this context always evaluates to true
context "px.snippets.make_context(snip)"
post_jump "jump_to_end_of_line(snip)"
snippet dbg_a "Description" 
`!p jump_to_second_when_first_is_empty(snip)
`std_logic_vector( downto 0)${1: := (others => '0')};$2
endsnippet       

post_jump "goto_eol(snip)"
snippet dbg_b
:= (others => '0')
endsnippet
             

########################
#  end of dev section  #
########################
 
snippet lib
library ${1};
	use $1.${2}.${3:all};${0}
endsnippet

snippet libs
library ieee;
	use ieee.std_logic_1164.ALL;
	use ieee.numeric_std.ALL;
endsnippet
 
snippet unisim
library unisim;
	use unisim.vcomponents.ALL;
endsnippet
        
snippet pr
process(${1})
begin`!p
if re.search('clk', t[1],re.IGNORECASE):
	snip >> 1
	snip += "if rising_edge(%s) then" % t[1]
	snip >> 1
	snip+=""
else:
	snip >> 1
	snip+=""
`${0}`!p
if re.search('clk', t[1],re.IGNORECASE):
	snip >> 1
	snip += "end if;"
else:
	snip.rv="" 
`
end process;
endsnippet

snippet sl 
signal ${1:${VISUAL}} : std_logic := '0';${0}
endsnippet

snippet sv 
signal ${1:${VISUAL}} : std_logic_vector(${2} downto 0) := (others => '0');
endsnippet
 
snippet ss 
signal ${1:${VISUAL}} : signed(${2} downto 0) := (others => '0');
endsnippet

snippet su 
signal ${1:${VISUAL}} : unsigned(${2} downto 0) := (others => '0');
endsnippet

snippet si 
signal ${1:${VISUAL}} : integer ${2:range ${3}} := 0;
endsnippet

snippet sb 
signal ${1:${VISUAL}} : boolean := ${2:false};
endsnippet

snippet vl 
variable ${1:${VISUAL}} : std_logic;
endsnippet

snippet vv 
variable ${1:${VISUAL}} : std_logic_vector(${2} downto 0);
endsnippet
                         
snippet vs 
variable ${1:${VISUAL}} : signed(${2} downto 0);
endsnippet
          
snippet vu 
variable ${1:${VISUAL}} : unsigned(${2} downto 0);
endsnippet
        
snippet vi 
variable ${1:${VISUAL}} : integer ${2:range ${3}};
endsnippet
        
snippet vb 
variable ${1:${VISUAL}} : boolean;
endsnippet
 
snippet il 
${1:${VISUAL}} : in  std_logic;
endsnippet

snippet iv 
${1:${VISUAL}} : in  std_logic_vector(${2} downto 0);
endsnippet
 
snippet ol 
${1:${VISUAL}} : out std_logic;
endsnippet

snippet ov 
${1:${VISUAL}} : out std_logic_vector(${2} downto 0);
endsnippet
                   

snippet bl "block..."
${1} : block
begin
    $0
end block $1;
endsnippet

snippet gfor "generate if"
${1} : for ${2:i} in 0 to ${3} generate
begin
    ${0}
end generate $1;
endsnippet

snippet gif "generate if"
${1} : if ${2} generate
begin
    ${0}
end generate $1;
endsnippet

# test_vect : std_logic_vector(10 downto 0):= (others => '0')
# (?: ) groups words, but does not create match
post_jump "goto_eol(snip)"
snippet "(\s*\w+\s*:\s*(?:inout|in|out)?\s*(\w+)(\(.*\))?\s*:=\s*)" "auto complete default signal value" r
`!p
if (match.group(2).lower() == "std_logic_vector") :
    snip.rv = match.group(1) + "(others => '0')"
elif (match.group(2).lower() == "unsigned") :
    snip.rv = match.group(1) + "(others => '0')"
elif (match.group(2).lower() == "signed") :
    snip.rv = match.group(1) + "(others => '0')"
elif (match.group(2).lower() == "integer") :
    snip.rv = match.group(1) + "0"
elif (match.group(2).lower() == "std_logic") :
    snip.rv = match.group(1) + "'0'"
else :
    snip.rv = match.group(1) + ""
`${0}
endsnippet

snippet ta "type array"
type $1 is array (integer range ${2:<>}) of ${3:std_logic_vector(${4} downto 0)};
endsnippet
#
snippet tr "type record"
type $1 is record
    ${0}
end record;
endsnippet

snippet while "while"
while ${1} loop
	${2}
end while;
endsnippet

snippet for
for ${1:i} in ${2:0 to ${3} - 1} loop
	${4}
end for;
endsnippet

